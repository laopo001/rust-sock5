mod local_server;
use local_server::LocalServer;
mod accept_connect;
use accept_connect::AcceptConnect;
use dns_lookup::{lookup_addr, lookup_host};
use std::io::{Error, ErrorKind, Result};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

use async_std::io;
use async_std::net::{TcpListener, TcpStream};
use async_std::prelude::*;
use async_std::task;

async fn accept(mut stream: TcpStream) -> std::io::Result<()> {
    // let (reader, writer) = &mut (&stream, &stream);

    let mut buffer = [0; 128];
    let n = stream.read(&mut buffer).await?;
    dbg!(&buffer[0..n]);
    if buffer[0] != 5 {
        println!("只支持sock5");
        return Ok(());
    }
    if buffer[1] != 1 || buffer[2] != 0 {
        println!("只支持不需要认证");
        return Ok(());
    }

    stream.write(&[5, 0]).await?;
    let mut buffer = [0; 128];
    let n = stream.read(&mut buffer).await?;
    dbg!(&buffer[0..n]);
    if buffer[0] != 5 {
        println!("只支持sock5");
        return Ok(());
    }
    if buffer[1] == 2 {
        println!("只支持TCP UDP");
        return Ok(());
    }
    let tcp = buffer[1] == 1;
    let attr_type = buffer[3];
    // IPv4地址 4字节长度
    if attr_type == 1 {
        println!("IP代理");
        let ip = &buffer[4..4 + 4];
        let port_arr = &buffer[8..8 + 2];
        let port = port_arr[0] as u16 * 256 + port_arr[1] as u16;
        dbg!(ip, port);
        let mut b = buffer[0..n].to_vec();
        b[1] = 0;
        stream.write(b.as_slice()).await?;

        // let mut buffer = [0; 512];
        // stream.read(&mut buffer).await?;
        // dbg!(&String::from_utf8(Vec::from(&buffer)).unwrap());

        let s = IpAddr::V4(Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3])).to_string()
            + ":"
            + &port.to_string();
        dbg!(&s);
        // let contents = "egg hi";
        // let response = format!(
        //     "HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}",
        //     contents.len(),
        //     contents
        // );
        // dbg!(response.as_str());
        // stream.write(response.as_bytes()).await?;
        // stream.flush().await?;

        // let mut buffer = [0; 512];
        // stream.read(&mut buffer).await?;
        // dbg!(&buffer);
        let mut upstream = TcpStream::connect(s).await?;

        // link_stream(stream, upstream).await?;
    } else if attr_type == 3 {
        // 域名
        println!("域名代理");
        let len = buffer[4] as usize;
        let hostname = String::from_utf8(Vec::from(&buffer[5..(5 + len)])).unwrap();
        dbg!(&hostname);
        let port_arr = &buffer[5 + len..5 + len + 2];
        let port = port_arr[0] as u16 * 256 + port_arr[1] as u16;
        let ip: Vec<std::net::IpAddr> = lookup_host(hostname.as_str()).unwrap();
        dbg!(ip[0], port);
        let mut b = buffer[0..n].to_vec();
        b[1] = 0;
        stream.write(b.as_slice()).await?;
        // connect(ip[0], port);
        let s = ip[0].to_string() + ":" + &port.to_string();
        dbg!(&s);
        let mut real_stream = TcpStream::connect(s).await?;
        // link_stream(stream, real_stream).await?;
    } else {
        todo!();
    }
    // IPv6地址 16个字节长度
    if attr_type == 4 {}
    Ok(())
}

async fn app() -> std::io::Result<()> {
    let listener = TcpListener::bind("0.0.0.0:7891").await?;
    let mut incoming = listener.incoming();

    while let Some(stream) = incoming.next().await {
        let mut stream = stream?;
        task::spawn(accept(stream));
    }
    Ok(())
}

async fn accept2(mut stream: TcpStream) -> std::io::Result<()> {
    let mut connect = AcceptConnect::new(stream);
    connect.authenticate().await?;
    let (ip, port, host) = connect.resolve_up_ip_port().await?;
    dbg!(&ip, &port, &host);
    let mut real_stream = TcpStream::connect(ip + ":" + port.as_str()).await?;
    link_stream(connect.stream, real_stream).await?;

    Ok(())
}
async fn start() -> std::io::Result<()> {
    let mut server = LocalServer::new("0.0.0.0:7891".to_string());
    server.start().await?;
    let mut incoming = server.listener.as_ref().unwrap().incoming();
    while let Some(stream) = incoming.next().await {
        let mut stream = stream?;

        task::spawn(accept2(stream));
    }
    Ok(())
}

fn main() {
    task::block_on(start());
    // task::block_on(app());
    // let mut server = LocalServer::new("0.0.0.0:7891".to_string());
    // task::block_on(async {
    //     server.start().await?;
    //     let mut incoming = server.listener.unwrap().incoming();
    //     1
    // });
}

async fn connect(ip: std::net::IpAddr, port: u16) -> std::io::Result<()> {
    let s = ip.to_string() + ":" + &port.to_string();
    dbg!(&s);
    let mut real_stream = TcpStream::connect(s).await?;

    Ok(())
}

pub async fn link_stream(a: TcpStream, b: TcpStream) -> Result<()> {
    let (ar, aw) = &mut (&a, &a);
    let (br, bw) = &mut (&b, &b);
    io::copy(ar, bw).race(io::copy(br, aw)).await?;
    Ok(())
}

async fn read(stream: &mut TcpStream) -> std::io::Result<Vec<u8>> {
    let mut buf = [0; 5120];
    let n = stream.read(&mut buf).await?;
    let res = Vec::from(&buf[0..n]);
    Ok(res)
}
